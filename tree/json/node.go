package json

import (
	"encoding/json"
	"fmt"
	"math"
	"strconv"

	"github.com/pbanos/botanic/feature"
	"github.com/pbanos/botanic/tree"
)

type node struct {
	ID               string           `json:"id"`
	ParentID         string           `json:"parentId,omitempty"`
	SubtreeIDs       []string         `json:"subtreeIds,omitempty"`
	FeatureCriterion *json.RawMessage `json:"criterion,omitempty"`
	SubtreeFeature   string           `json:"feature,omitempty"`
	Prediction       *json.RawMessage `json:"prediction,omitempty"`
}

type jsonCriterion struct {
	Type    string `json:"type"`
	Feature string `json:"feature"`
	Value   string `json:"value,omitempty"`
	A       string `json:"a,omitempty"`
	B       string `json:"b,omitempty"`
}

type jsonPrediction struct {
	Probabilities map[string]float64 `json:"probabilities,omitempty"`
	Weight        int                `json:"weight,omitempty"`
}

/*
MarshalJSONNode returns a slice of bytes with the node serialized to JSON and an error.
A node serialization includes the following properties:
  * "id": a string with the id of the node
  * "parentId": a string with the id of the parent of the node
  * "prediction": the prediction of the label at this point in the tree
  * "subtreeIds": an array with the ids of the nodes opening the subtrees under
  this node.
  * "criterion": the feature criterion for the node, that is, the constraint on
  samples that distinguish it from its sibling nodes.
  * "feature": the feature on which the subtree nodes have a constraint, that is,
  the feature that is dividing the data
*/
func MarshalJSONNode(n *tree.Node) ([]byte, error) {
	jn := &node{
		ID:       n.ID,
		ParentID: n.ParentID,
	}
	if len(n.SubtreeIDs) > 0 {
		jn.SubtreeIDs = n.SubtreeIDs
	}
	if n.FeatureCriterion != nil {
		fc, err := MarshalJSONCriterion(n.FeatureCriterion)
		if err != nil {
			return nil, err
		}
		rfc := json.RawMessage(fc)
		jn.FeatureCriterion = &rfc
	}
	if n.Prediction != nil {
		p, err := json.Marshal(&jsonPrediction{Probabilities: n.Prediction.Probabilities(), Weight: n.Prediction.Weight()})
		if err != nil {
			return nil, err
		}
		rp := json.RawMessage(p)
		jn.Prediction = &rp
	}
	if n.SubtreeFeature != nil {
		jn.SubtreeFeature = n.SubtreeFeature.Name()
	}
	return json.Marshal(jn)
}

/*
UnmarshalJSONNodeWithFeatures takes a tree.Node, slice of bytes containing a serialized node
and a slice with the available features and loads the serialized data into the given node.
The slice of bytes is expected to have the node serialized in JSON format as generated by
MarshalJSONNode.
*/
func UnmarshalJSONNodeWithFeatures(n *tree.Node, b []byte, features []feature.Feature) error {
	jn := &node{}
	err := json.Unmarshal(b, jn)
	if err != nil {
		return err
	}
	if jn.FeatureCriterion != nil {
		n.FeatureCriterion, err = UnmarshalJSONCriterion(*jn.FeatureCriterion, features)
		if err != nil {
			return err
		}
	}
	if jn.Prediction != nil {
		n.Prediction, err = UnmarshalJSONPrediction(*jn.Prediction)
		if err != nil {
			return err
		}
	}
	n.ID = jn.ID
	n.ParentID = jn.ParentID
	if len(jn.SubtreeIDs) > 0 {
		n.SubtreeIDs = jn.SubtreeIDs
	}
	if jn.SubtreeFeature != "" {
		var nf feature.Feature
		for _, f := range features {
			if f.Name() == jn.SubtreeFeature {
				nf = f
				break
			}
		}
		if nf == nil {
			return fmt.Errorf("unmarshalling node %v: unknown feature %v", n.ID, jn.SubtreeFeature)
		}
		n.SubtreeFeature = nf
	}
	return nil
}

/*
MarshalJSONCriterion takes a feature.Criterion and returns a slice
of bytes containing its serialization to JSON. It uses the
MarshalJSONContinuousCriterion, MarshalJSONDiscreteCriterion and
MarshalJSONUndefinedCriterion functions to serialize a
feature.ContinuousCriterion, a feature.DiscreteCriterion or
a feature.UndefinedCriterion respectively. It returns an error
if the feature.Criterion is not one of these or if there is
an error during the serialization.
*/
func MarshalJSONCriterion(fc feature.Criterion) ([]byte, error) {
	switch c := fc.(type) {
	case feature.ContinuousCriterion:
		return MarshalJSONContinuousCriterion(c)
	case feature.DiscreteCriterion:
		return MarshalJSONDiscreteCriterion(c)
	case feature.UndefinedCriterion:
		return MarshalJSONUndefinedCriterion(c)
	default:
		return nil, fmt.Errorf("unknown type of feature.Criterion %T", fc)
	}
}

/*
MarshalJSONContinuousCriterion takes a feature.ContinuousCriterion and
returns a serialization of it into JSON or an error. The serialization
is a JSON object with the following fields:
* "type": a string set to "continuous"
* "feature": a string set to the name of the feature of the criterion
* "a": a number specifying where the interval of the criterion starts
or the string "-Inf" if it has no finite start.
* "b": a number specifying where the interval of the criterion ends
or the string "+Inf" if it has no finite end.
*/
func MarshalJSONContinuousCriterion(cfc feature.ContinuousCriterion) ([]byte, error) {
	a, b := cfc.Interval()
	sa := fmt.Sprintf("%f", a)
	sb := fmt.Sprintf("%f", b)
	return json.Marshal(&jsonCriterion{
		Type:    "continuous",
		Feature: cfc.Feature().Name(),
		A:       sa,
		B:       sb,
	})
}

/*
MarshalJSONDiscreteCriterion takes a feature.DiscreteCriterion and
returns a serialization of it into JSON or an error. The serialization
is a JSON object with the following fields:
* "type": a string set to "discrete"
* "feature": a string set to the name of the feature of the criterion
* "value": a string with the value that satisfies the criterion.
*/
func MarshalJSONDiscreteCriterion(dfc feature.DiscreteCriterion) ([]byte, error) {
	return json.Marshal(&jsonCriterion{
		Type:    "discrete",
		Feature: dfc.Feature().Name(),
		Value:   dfc.Value(),
	})
}

/*
MarshalJSONUndefinedCriterion takes a feature.UndefinedCriterion and
returns a serialization of it into JSON or an error. The serialization
is a JSON object with the following fields:
* "type": a string set to "undefined"
* "feature": a string set to the name of the feature of the criterion
*/
func MarshalJSONUndefinedCriterion(u feature.UndefinedCriterion) ([]byte, error) {
	return json.Marshal(&jsonCriterion{
		Type:    "undefined",
		Feature: u.Feature().Name(),
	})
}

func (jc *jsonCriterion) Criterion(features []feature.Feature) (feature.Criterion, error) {
	var f feature.Feature
	for _, feat := range features {
		if feat.Name() == jc.Feature {
			f = feat
			break
		}
	}
	if f == nil {
		return nil, fmt.Errorf("unknown feature '%s'", jc.Feature)
	}
	switch jc.Type {
	case "continuous":
		return jc.toContinuousCriterion(f)
	case "discrete":
		return jc.toDiscreteCriterion(f)
	case "undefined":
		return jc.toUndefinedCriterion(f)
	}
	return nil, fmt.Errorf("unknown feature criterion type '%s'", jc.Type)
}

// UnmarshalJSONCriterion takes a slice of bytes with a JSON-marshalled Criterion
// and a slice of features and returns the Criterion or an error. The slice of
// features should include exactly one feature with the serialized criterion's
// feature and for continuous and discrete criteria, the feature should be of
// the correspoding feature type, otherwise an error is returned.
func UnmarshalJSONCriterion(b []byte, features []feature.Feature) (feature.Criterion, error) {
	jc := &jsonCriterion{}
	err := json.Unmarshal(b, jc)
	if err != nil {
		return nil, err
	}
	return jc.Criterion(features)
}

func (jc *jsonCriterion) toUndefinedCriterion(f feature.Feature) (feature.Criterion, error) {
	return feature.NewUndefinedCriterion(f), nil
}

func (jc *jsonCriterion) toDiscreteCriterion(f feature.Feature) (feature.Criterion, error) {
	df, ok := f.(*feature.DiscreteFeature)
	if !ok {
		return nil, fmt.Errorf("expected discrete feature for discrete criterion but found %T feature %v", f, f.Name())
	}
	return feature.NewDiscreteCriterion(df, jc.Value), nil
}

func (jc *jsonCriterion) toContinuousCriterion(f feature.Feature) (feature.Criterion, error) {
	cf, ok := f.(*feature.ContinuousFeature)
	if !ok {
		return nil, fmt.Errorf("expected continuous feature for continuous criterion but found %T feature %v", f, f.Name())
	}
	var a, b float64
	var err error
	if jc.A == "-Inf" {
		a = math.Inf(-1)
	} else {
		a, err = strconv.ParseFloat(jc.A, 64)
		if err != nil {
			return nil, err
		}
	}
	if jc.B == "+Inf" {
		b = math.Inf(+1)
	} else {
		b, err = strconv.ParseFloat(jc.B, 64)
		if err != nil {
			return nil, err
		}
	}
	return feature.NewContinuousCriterion(cf, a, b), nil
}

/*
UnmarshalJSONPrediction takes a slice of bytes and returns
a pointer to a new tree.Prediction with the data from the slice
unmarshalled into it or an error. The slice of bytes is expected
to contain a JSON object with the following fields:
* "probabilities": a JSON object with string keys (values) and
numeric (float64) values (probability of that value)
* "weight": a number (integer) corresponding to the number of
samples in the dataset from which the prediction was made.
*/
func UnmarshalJSONPrediction(b []byte) (*tree.Prediction, error) {
	jp := &jsonPrediction{}
	err := json.Unmarshal(b, jp)
	if err != nil {
		return nil, err
	}
	return tree.NewPrediction(jp.Probabilities, jp.Weight), nil
}
