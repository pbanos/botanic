package json

import (
	"encoding/json"
	"fmt"
	"math"
	"strconv"

	"github.com/pbanos/botanic/feature"
	"github.com/pbanos/botanic/tree"
)

type node struct {
	ID               string           `json:"id"`
	ParentID         string           `json:"parentId,omitempty"`
	SubtreeIDs       []string         `json:"subtreeIds,omitempty"`
	FeatureCriterion *json.RawMessage `json:"criterion,omitempty"`
	SubtreeFeature   string           `json:"feature,omitempty"`
	Prediction       *json.RawMessage `json:"prediction,omitempty"`
}

type jsonCriterion struct {
	Type    string `json:"type"`
	Feature string `json:"feature"`
	Value   string `json:"value,omitempty"`
	A       string `json:"a,omitempty"`
	B       string `json:"b,omitempty"`
}

type jsonPrediction struct {
	Probabilities map[string]float64 `json:"probabilities,omitempty"`
	Weight        int                `json:"weight,omitempty"`
}

/*
MarshalJSONNode returns a slice of bytes with the node serialized to JSON and an error.
A node serialization includes the following properties:
  * "id": a string with the id of the node
  * "parentId": a string with the id of the parent of the node
  * "prediction": the prediction of the classFeature at this point in the tree
  * "subtreeIds": an array with the ids of the nodes opening the subtrees under
  this node.
  * "criterion": the feature criterion for the node, that is, the constraint on
  samples that distinguish it from its sibling nodes.
  * "feature": the feature on which the subtree nodes have a constraint, that is,
  the feature that is dividing the data
*/
func MarshalJSONNode(n *tree.Node) ([]byte, error) {
	jn := &node{
		ID:       n.ID,
		ParentID: n.ParentID,
	}
	if len(n.SubtreeIDs) > 0 {
		jn.SubtreeIDs = n.SubtreeIDs
	}
	if n.FeatureCriterion != nil {
		fc, err := MarshalJSONCriterion(n.FeatureCriterion)
		if err != nil {
			return nil, err
		}
		rfc := json.RawMessage(fc)
		jn.FeatureCriterion = &rfc
	}
	if n.Prediction != nil {
		p, err := json.Marshal(&jsonPrediction{Probabilities: n.Prediction.Probabilities(), Weight: n.Prediction.Weight()})
		if err != nil {
			return nil, err
		}
		rp := json.RawMessage(p)
		jn.Prediction = &rp
	}
	if n.SubtreeFeature != nil {
		jn.SubtreeFeature = n.SubtreeFeature.Name()
	}
	return json.Marshal(jn)
}

/*
UnmarshalJSONNodeWithFeatures takes a tree.Node, slice of bytes containing a serialized node
and a slice with the available features and loads the serialized data into the given node.
The slice of bytes is expected to have the node serialized in JSON format as generated by
MarshalJSONNode.
*/
func UnmarshalJSONNodeWithFeatures(n *tree.Node, b []byte, features []feature.Feature) error {
	jn := &node{}
	err := json.Unmarshal(b, jn)
	if err != nil {
		return err
	}
	if jn.FeatureCriterion != nil {
		n.FeatureCriterion, err = UnmarshalJSONCriterion(*jn.FeatureCriterion, features)
		if err != nil {
			return err
		}
	}
	if jn.Prediction != nil {
		n.Prediction, err = UnmarshalJSONPrediction(*jn.Prediction)
		if err != nil {
			return err
		}
	}
	n.ID = jn.ID
	n.ParentID = jn.ParentID
	if len(jn.SubtreeIDs) > 0 {
		n.SubtreeIDs = jn.SubtreeIDs
	}
	if jn.SubtreeFeature != "" {
		var nf feature.Feature
		for _, f := range features {
			if f.Name() == jn.SubtreeFeature {
				nf = f
				break
			}
		}
		if nf == nil {
			return fmt.Errorf("unmarshalling node %v: unknown feature %v", n.ID, jn.SubtreeFeature)
		}
		n.SubtreeFeature = nf
	}
	return nil
}

func MarshalJSONCriterion(fc feature.Criterion) ([]byte, error) {
	switch c := fc.(type) {
	case feature.ContinuousCriterion:
		return MarshalJSONContinuousCriterion(c)
	case feature.DiscreteCriterion:
		return MarshalJSONDiscreteCriterion(c)
	case feature.UndefinedCriterion:
		return MarshalJSONUndefinedCriterion(c)
	default:
		return nil, fmt.Errorf("unknown type of feature.Criterion %T", fc)
	}
}

func MarshalJSONContinuousCriterion(cfc feature.ContinuousCriterion) ([]byte, error) {
	a, b := cfc.Interval()
	sa := fmt.Sprintf("%f", a)
	sb := fmt.Sprintf("%f", b)
	return json.Marshal(&jsonCriterion{
		Type:    "continuous",
		Feature: cfc.Feature().Name(),
		A:       sa,
		B:       sb,
	})
}

func MarshalJSONDiscreteCriterion(dfc feature.DiscreteCriterion) ([]byte, error) {
	return json.Marshal(&jsonCriterion{
		Type:    "discrete",
		Feature: dfc.Feature().Name(),
		Value:   dfc.Value(),
	})
}

func MarshalJSONUndefinedCriterion(u feature.UndefinedCriterion) ([]byte, error) {
	return json.Marshal(&jsonCriterion{
		Type:    "undefined",
		Feature: u.Feature().Name(),
	})
}

func (jc *jsonCriterion) Criterion(features []feature.Feature) (feature.Criterion, error) {
	var f feature.Feature
	for _, feat := range features {
		if feat.Name() == jc.Feature {
			f = feat
			break
		}
	}
	if f == nil {
		return nil, fmt.Errorf("unknown feature '%s'", jc.Feature)
	}
	switch jc.Type {
	case "continuous":
		return jc.toContinuousCriterion(f)
	case "discrete":
		return jc.toDiscreteCriterion(f)
	case "undefined":
		return jc.toUndefinedCriterion(f)
	}
	return nil, fmt.Errorf("unknown feature criterion type '%s'", jc.Type)
}

// UnmarshalJSONCriterion takes a slice of bytes with a JSON-marshalled Criterion
// and a slice of features and returns the Criterion or an error. The slice of
// features should include exactly one feature with the serialized criterion's
// feature and for continuous and discrete criteria, the feature should be of
// the correspoding feature type, otherwise an error is returned.
func UnmarshalJSONCriterion(b []byte, features []feature.Feature) (feature.Criterion, error) {
	jc := &jsonCriterion{}
	err := json.Unmarshal(b, jc)
	if err != nil {
		return nil, err
	}
	return jc.Criterion(features)
}

func (jc *jsonCriterion) toUndefinedCriterion(f feature.Feature) (feature.Criterion, error) {
	return feature.NewUndefinedCriterion(f), nil
}

func (jc *jsonCriterion) toDiscreteCriterion(f feature.Feature) (feature.Criterion, error) {
	df, ok := f.(*feature.DiscreteFeature)
	if !ok {
		return nil, fmt.Errorf("expected discrete feature for discrete criterion but found %T feature %v", f, f.Name())
	}
	return feature.NewDiscreteCriterion(df, jc.Value), nil
}

func (jc *jsonCriterion) toContinuousCriterion(f feature.Feature) (feature.Criterion, error) {
	cf, ok := f.(*feature.ContinuousFeature)
	if !ok {
		return nil, fmt.Errorf("expected continuous feature for continuous criterion but found %T feature %v", f, f.Name())
	}
	var a, b float64
	var err error
	if jc.A == "-Inf" {
		a = math.Inf(-1)
	} else {
		a, err = strconv.ParseFloat(jc.A, 64)
		if err != nil {
			return nil, err
		}
	}
	if jc.B == "+Inf" {
		b = math.Inf(+1)
	} else {
		b, err = strconv.ParseFloat(jc.B, 64)
		if err != nil {
			return nil, err
		}
	}
	return feature.NewContinuousCriterion(cf, a, b), nil
}

func UnmarshalJSONPrediction(b []byte) (*tree.Prediction, error) {
	jp := &jsonPrediction{}
	err := json.Unmarshal(b, jp)
	if err != nil {
		return nil, err
	}
	return tree.NewPrediction(jp.Probabilities, jp.Weight), nil
}
